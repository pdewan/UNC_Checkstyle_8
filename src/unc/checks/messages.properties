methodlimit =max. number of methods is {0}
variableDoesNotHaveClassType = Class {0} rather than interface used as the type of variable/function {1}
variableHasClassType = Interface {0} used as the type of variable/function {1}. Good!
variableHasInterfaceType = Interface {0} used as the type of variable/function {1}. Good!
classIsNotType =  A class should implement a single (possibly extending) interface
duplicateShortTypeName = Repeated short type name in {0}, many checks for these types will not work
noFullTypeName =  Used full type name {0}
interfaceDefined = Interface matching tag {0} defined
typeDefined = {1}  matching tag {0} defined {2} {3} {4} {5}
tags = Tags defined: {0} 
variables = Variables defined: {10} 
interfaces = Interfaces defined: {0} 
methods = Methods defined: {0} 
properties = Properties defined: {0} 
innerTypes = Inner types defined: {0} 
superTypes = Super types: {0}
accessModifiersUsed = Access modifiers used: {0} 
aggregateStatistics = Aggregate statistics: {0}
classDefined = Class/Interface matching tag {0} defined
constantDefined = Named Constant {0} defined
finalParameterDefined = Named Constant {0} defined
equalsAvoidedNull = Equals invoked on constant {0} rather than variable {1}. Good!
equalsDidNotAvoidNull = Equals invoked on variable {0} rather than the constant {1}.
expectedTypes =Expected type names/tags 
classIsGeneric = Class should be generic
publicMethodsOverride = All public methods override. Good! 
publicMethodsDoNotOverride = The following public methods do not override: {0}
classHasExactlyOneInterface = Class has exactly one extending interface. Good! 
classDoesNotHaveExactlyOneInterface =  A class with instance methods should have exactly one (possibly extending and empty) interface      
classHasAtLeastOneInterface = Class has no instance variables or at least one interface. Good!
classHasProjectSuperClass =  Class has project super class. Good!
interfaceHasProjectSuperType = Interface has project super type. Good!
classDoesNotHaveAtLeastOneInterface =  A class with instance methods should have at least one (possibly extending and empty) interface     
illegalMethodCall = Class called disallowed method {0}
uncessaryMethodCall = Class called unnecessary method {0}
legalMethodCall = Class called legal method {0}. Good!
expectedMethodCall = Class called expected method {0}
missingMethodCall = Class has not made expected call {0}
missingMethodText = Class does not execute expected code {0}
illegalTypeDefined =  You are expected to use existing version of this type rather than provide your own code for it
illegalTypeImported =  Used disallowed class {0} 
illegalInitCall =  Init method {0} should be called by an init method or a constructor
legalInitCall = Init method {0} called by an init method or a constructor
illegalComponentInstantiation = Instantiation of property class {0} should occur in init or constructor
legalComponentInstantiation = Instantiation of property class {0} occurred in init or constructor
staticVariable =  Non final static variable {0} defined, should it be instance or final?
functionAssignsGlobal =Function {0} assigns to a global variable 
setterAssignsGlobal = Setter {0} does not assign to a global variable
methodCallsInternalMethod = Method {0} calls > 0 internal methods {1}. Good!  
noStructuredSetter = Setter for property {0} of type {1} should not be defined
expectedGlobals = Missing global variable {0} of type {1}
expectedGetters = Missing getter for property {0} of type {1}
expectedSetters = Missing setter for property {0} of type {1}
expectedSignatures = Missing signature: {0}
expectedDeclaredSignatures = Missing declared signature: {0}
expectedClassInstantiations = Type {1} should be instantiated by {0} 
multipleInstantiatingMethods = Type {0} should be instantiated (only) by {2} rather than {1}
invalidClassInstantiation =  Class {0} should not instantiate {1}
expectedConstructors = Missing constructor: {0}
expectedPattern = Missing pattern: {0}
expectedInterfaces = Missing interface: {0}
expectedSuperTypes = Missing supertype: {0}
invalidSuperTypes = Sould not have super type {0}
peerDuplicatedSignatures =  Signatures {1} common with {0} not defined in a common type 
peerOverriddingSignatures =Signatures {1} common with {0} defined in common types {2}. Good!
peerCommonProperties = Property {0} common between {1} and {2} not inherited
minComponentObjects =  Min object components: {0}, actual {1}
minDeclaredMethods = Min declared methods: {0}, actual {1}
minCalledMethods = Min called methods: {0}, actual {1}
minDescendantObjects = Min object descendants: {1}, actual {0}
minDescendantShapes = Min shape descendants: {1}, actual {0}
missingPropertyNotification =  Notified property {0}  does not have a getter
invalidPropertyNotification = Notified property {0} should be a string literal or a global constant in notifying class (for checks to work)
structuredPropertyNotification = Notified property {0} is structured
missingActualProperty = Declared property {0} does not have a getter
missingActualEditableProperty = Declared editable property {0} does not have a setter
invalidPackageName =  Package name {0} does not have one of the following prefixes {1}
stBuilder = Symbol table built for {0}
expectedConstructs = Specification {0}, matching construct {1} not found
expectedNodes = Specification {0}, node {1} not matched
bulkierThen = Then part much bulkier than else part of if. Invert if condition to swap then and else blocks. Then#: {0}. Else#:{1}. Ratio:{2}
bulkierElse = Else part much smaller than then part of if. Good style.  Then#:{0}. Else#: {1}. Ratio:{2}
nestedBlockDepth = Loop level {0} greater than max {1}, consider making it a separate method unless it introduces unsafe global variables 
methodBlockLimit = Method {0}, loop count {1} greater than max {62}, consider making it a separate method unless it introduces unsafe global variables 
thenBranching = In method {0}, rewrite if to use else-ifs  rather than nested ifs (that is, use else branching instead of then branching)
elseBranching = In method {0}, found else branching. Good!
classDecomposition = Consider separating the following method sets into different types {0}
liberalMagicNumber = Magic number {0}  
mnemonicNamePrint = Identifier Components= {0}
minimumVowelInNameCheck = Component {1} in Identifier {0} does  not have at least {2} vowels
minimumLettersInNameCheck =Component {1} in Identifier {0} does  not have at least {2} letters
nameInDictionaryCheck =  Component {1} in Identifier {0} is not in dictionary
methodAccessesGlobal = Method {0} does not access global {1}
methodDoesNotAccessGlobal = Method {0} does not access global {1} 
methodAccessModifierUnmatched = Method {0} has access {1} but needs access {2} (difference {3}) in used classes {4} needing access {5}
methodAccessModifierMatched = Method {0}  has access {1} and needs access {2} (difference {3})  in used classes {4} needing access {5}