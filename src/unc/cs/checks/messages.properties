methodlimit = {0} {1} max. number of methods is {1}
variableDoesNotHaveClassType = {0} {1} Class {3} rather than interface used as the type of variable/function {4}
variableHasClassType = {0} {1} Interface {3} used as the type of variable/function {4}
variableHasInterfaceType = {0} {1} Interface {3} used as the type of variable/function {4}. Good!
classIsNotType = {0} {1} A class should implement a single (possibly extending) interface
duplicateShortTypeName = {0} {1} Repeated short type name in {3}, many checks for these types will not work
noFullTypeName = {0} {1} Used full type name {3}
interfaceDefined = {0} {1} Interface {2} matching tag {3} defined
typeDefined = {0} {1} {4} {2} matching tag {3} defined {5} {6} {7} {8}
classDefined = {0} {1} Class/Interface {2} matching tag {3} defined
constantDefined = Named Constant {0} defined
finalParameterDefined = Named Constant {0} defined
equalsAvoidedNull = Equal avoided null:String {0} is lhs of equals. Good!
expectedTypes = {0} Expected type names/tags {1}
classIsGeneric = {0} {1} should be generic
classHasExactlyOneInterface = {0} {1} {2} Class with instance methods has exactly one interface 
classDoesNotHaveExactlyOneInterface = {0} {1} {2} A class with instance methods should have exactly one (possibly extending and empty) interface      
classHasAtLeastOneInterface = {0} {1} {2} Class has at least one interface. Good!
classHasProjectSuperClass = {0} {1} {2} Class has project super class. Good!
interfaceHasProjectSuperType = {0} {1} {2} Interface has project super type. Good!
classDoesNotHaveAtLeastOneInterface = {0} {1} {2} A class with instance methods should have at least one (possibly extending and empty) interface     
illegalMethodCall = {0} {1} called disallowed method {3}
uncessaryMethodCall = {0} {1} called unnecessary method {3}
legalMethodCall = {0} {1} called legal method {3}
expectedMethodCall = {0} {1} called expected method {3}
missingMethodCall = {0} {1} has not made expected call {3}
missingMethodText = {0} {1} does not execute expected code {3}
illegalTypeDefined = {0} {1} You are expected to use existing version of type {2} rather than provide your own code for it
illegalTypeImported = {0} {1} Used disallowed class {3} 
illegalInitCall = {0} {1} init method {2} should be called by an init method or a constructor
legalInitCall = {0} {1} init method {2} called by an init method or a constructor
illegalComponentInstantiation = {0} {1} Instantiation of property class {2} should occur in init or constructor
legalComponentInstantiation = {0} {1} Instantiation of property class {2} occurred in init or constructor
staticVariable = {0} {1} Non final static variable {2} defined, should it be instance or final?
functionAssignsGlobal ={0} {1} In type {2}, function {3} assigns to a global variable 
setterAssignsGlobal = {0} {1} In type {2}, setter {3} does not assign to a global variable
methodCallsInternalMethod = {0} {1} In type {2}, method {3} calls > 0 internal methods {4}. Good!  
noStructuredSetter = {0} {1} Setter for property {2} of type {3} should not be defined
expectedGlobals = {0} {1} In type {2} missing global variable {3} of type {4}
expectedGetters = {0} {1} In type {2}, missing getter for property {3} of type {4}
expectedSetters = {0} {1} In type {2}, missing setter for property {3} of type {4}
expectedSignatures = {0} {1} In type {4}, missing signature: {3}
expectedDeclaredSignatures = {0} {1} In type {4}, missing declared signature: {3}
expectedClassInstantiations = {0} {1} Type {4} should be instantiated by {3} 
multipleInstantiatingMethods = {0} {1} Type {3} should be instantiated (only) by {2} rather than {4}
invalidClassInstantiation = {0} {1} Class {3} should not instantiate {4}
expectedConstructors = {0} {1} In type {4}, missing constructor: {3}
expectedPattern = {0} {1} In type {3}, missing pattern: {2}
expectedInterfaces = {0} {1} In type {4}, missing interface: {3}
expectedSuperTypes = {0} {1} In type {4}, missing supertype: {3}
invalidSuperTypes = {0} {1} Type {3} should not have super type {2}
peerCommonSignatures = {0} {1} Signature {2} common between {3} and {4} not inherited
peerCommonProperties = {0} {1} Property {2} common between {3} and {4} not inherited
minComponentObjects = {0} {1} Min object components: {3}, actual {2}
minDeclaredMethods = {0} {1} Min declared methods: {3}, actual {2}
minCalledMethods = {0} {1} Min called methods: {3}, actual {2}
minDescendantObjects = {0} {1} Min object descendants: {3}, actual {2}
minDescendantShapes = {0} {1} Min shape descendants: {3}, actual {2}
missingPropertyNotification = {0} {1} Notified property {3}  does not have a getter
invalidPropertyNotification = {0} {1} Notified property {3} should be a string literal or a global constant in notifying class (for checks to work)
structuredPropertyNotification = {0} {1} Notified property {2} is structured
missingActualProperty = {0} {1} Declared property {2} does not have a getter
missingActualEditableProperty = {0} {1} Declared editable property {2} does not have a setter
invalidPackageName = {0} {1} Package name {3} does not have one of the following prefixes {4}
stBuilder = {0} {1}  Symbol table built for {2}
expectedConstructs = {0} {1} In type {3}, specification {2}, matching construct {4} not found
expectedNodes = {0} {1} In type {3}, specification {2}, node {4} not matched
bulkierThen = {0} {1} In type {2},  then part much bulkier than else part of if. Invert if condition to swap then and else blocks. Then#: {3}. Else#:{4}. Ratio:{5}
bulkierElse = {0} {1} In type {2},  else part much smaller than then part of if. Good style.  Then#:{4}. Else#: {3}. Ratio:{5}
nestedBlockDepth = {0} {1} In type {2}, loop level {4} greater than max {5}, consider making it a separate method unless it introduces unsafe global variables 
methodBlockLimit = {0} {1} In type {2}, method {3}, loop count {5} greater than max {6}, consider making it a separate method unless it introduces unsafe global variables 
thenBranching = {0} {1} In type {2},  method {3}, rewrite if to use else-ifs  rather than nested ifs (that is, use else branching instead of then branching)
elseBranching = {0} {1} In type {2},  method {3}, found else branching. Good!
classDecomposition = {0} {1} In type {2}, consider separarting the following method sets into different types {3}
liberalMagicNumber = {0} {1} In type {2}, magic number {3} in expression list {4} 
mnemonicNamePrint = {2} {0} Identifier Components= {1}
minimumVowelInNameCheck = {0}  Component {2} in Identifier {1} does  not have at least {3} vowels
minimumLettersInNameCheck = {0} Component {2} in Identifier {1} does  not have at least {3} letters
nameInDictionaryCheck =  {0} Component {2} in Identifier {1} is not in dictionary
methodAccessesGlobal = {0} {1} In class {2} method {3} does not access global {4}
methodDoesNotAccessGlobal = {0} {1} In class {2} method {3} does not access global {4} 
methodAccessModifierUnmatched = {0} {1} In class {2} method {3} has access {4} but needs access {5} (difference {6}) in used classes {7} needing access {8}
methodAccessModifierMatched = {0} {1} In class {2} method {3}  has access {4} and needs access {5} (difference {6})  in used classes {7} needing access {8}